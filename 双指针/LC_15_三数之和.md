# LeetCode 15. 三数之和

### 1. 题目链接

[https://leetcode.cn/problems/3sum/?envType=study-plan-v2&envId=top-100-liked]

### 2. 我的初次思路与遇到的问题 (The Error in "Error Log")

*在这里详细记录你最开始的想法，哪怕是错误的。*

先排序，然后遍历一遍数组（最多到n-3，确保从那个数字开始后有三个数），然后两个指针left和right分别指向当前数字右边一个和数组的最后一个数字，计算三数之和，如果等于sum，那么left++且right--，移动到下一组不重复的left和right；如果大于sum，则right左移（变小和），如果大于-num，则left右移（变大和），直到相遇还没有遇到，则跳到下一个数。

### 3. 核心解法：排序 + 双指针

**3.1 思路分析**

难点是如何处理不重复的结果。最优解法是：**排序后，固定一个数，然后用双指针法在剩余部分寻找另外两个数**。

1.  **排序**：升序排序`sort(nums.begin(),nums.end());`。

2.  **固定第一个数**：遍历数组，用 `i` 固定第一个数 `nums[i]`。

3.  **双指针查找**：在 `nums[i]` 右边的区间内，设置 `left = i + 1` 和 `right = n - 1` 两个指针。
    * 计算三数之和`sum`。
    * 如果 `sum == 0`，说明找到了一个解。将 `{nums[i], nums[left], nums[right]}` 存入结果。然后，为了避免重复，`left` 和 `right` 都需要**向内移动**，并跳过所有与刚刚记录下的值相同的元素。
    * 如果 `sum > 0`，说明和太大了，需要减小。移动右指针 `right--`。
    * 如果 `sum < 0`，说明和太小了，需要增大。移动左指针 `left++`。

**3.2 代码实现 (C++)**

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        int n = nums.size();
        sort(nums.begin(),nums.end());
        for(int i = 0; i <= n - 3; i++){
            if (nums[i] > 0) break; // 剪枝优化
            if(i && nums[i-1] == nums[i]) continue; // 外层去重

            int left = i + 1;
            int right = n - 1;

            while(left < right){
                int sum = nums[i] + nums[left] + nums[right];
                if(sum == 0){
                    res.push_back({nums[i],nums[left],nums[right]});
                    while(left < right && nums[left] == nums[left + 1]){left++;}
                    while(left < right && nums[right] == nums[right - 1]){right--;}
                    // 移动指针到下一个不同的位置
                    left++;
                    right--;
                }
                else if(sum > 0){
                    right--;
                }
                else{
                    left++;
                }
            }
        }
        return res;
    }
};
```

### 4. 复杂度分析

- **时间复杂度**: $O(N^2)$。排序的时间复杂度是 $O(N \log N)$。主体部分是 $O(N^2)$。
- **空间复杂度**: $O(N)$。这取决于排序算法使用的栈空间。

### 5. 总结与反思

- **升维与降维**：将三数之和问题，通过“固定一个数”，巧妙地转化为了我们熟悉的“两数之和”问题，这是一种重要的降维思想。
- **排序是前提**：双指针法通常需要在一个有序的序列上进行，排序是应用该技巧的关键预处理步骤。
- **去重逻辑的严谨性**：处理要求不重复结果的题目时，必须仔细考虑所有可能产生重复的地方，并设计相应的去重逻辑。在本题中，外层和内层都需要去重。需要重点关注这一点。