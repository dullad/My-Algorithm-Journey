# LeetCode 42. 接雨水

### 1. 题目链接

[https://leetcode.cn/problems/trapping-rain-water/?envType=study-plan-v2&envId=top-100-liked]

### 2. 我的初次思路与遇到的问题 (The Error in "Error Log")

*在这里详细记录你最开始的想法，哪怕是错误的。*

首先从左边向右边按以下逻辑遍历：先找到数组最大值，从一个非0值开始，向右找到第一个大于等于这个值的数，统计这两个数之间的雨水数量（用短边作为高度）。然后从新数开始，继续往右找大于等于该值的数，统计雨水数量。直到遍历到最大值下标，最大值左边的雨水就统计完了。然后从右往左遍历一遍，也可以统计最大值右边的雨水量。

### 3. 核心解法：双指针

**3.1 思路分析**

1. 分割到全局最大（最好想到）
    - 先扫描一次找到最大高度的下标maxID
    - 对maxID左右侧，分别从左向右和从右向左维护`curMax`，每个位置能接 `curMax-height[i]`的雨水.

2. 双指针法：我们不需要预先知道所有的最大值，我们只需要知道确定较短的那一边。
    - 使用左右指针 left, right 及左右最高 leftMax, rightMax。每次比较 height[left] 和 height[right]，移动较小一侧并用对应的 sideMax 计算贡献（水量由较短一侧决定）。一格一格统计每一格能有的水量。
    - 如果 height[left] < height[right]，此时对于 left 指针所在的位置，它的左边最高墙 leftMax 是确定的（我们在移动过程中维护的）。虽然它的右边最高墙 rightMax 具体是哪根不知道，但可以确定右边至少有一根墙是 height[right]，而且 height[right] > height[left]。所以，对于 left 位置来说，它的短板一定是左边。

3. 统计每个数左右最大高度
    - 使用l[i]表示i左边的最大高度，使用r[i]表示i右边的最大高度。
    - l[i]=max(l[i-1],height[i-1]); r[i]=max(r[i+1],height[i+1]);
    - 每个位置能接的雨水数为其左右最大高度的最小值减去height[i]（如果小于等于0，则接的雨水数为0）.

**3.2 代码实现 (C++)**

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        if (n < 3) return 0;
        int maxID = 0;
        int res = 0;
        for(int i = 0; i < n; i++){
            if(height[i] > height[maxID]){
                maxID = i;
            }
        }
        int curMax = 0;
        for(int i = 0; i < maxID; i++){
            curMax = max(curMax, height[i]);
            res += curMax - height[i];
        }
        curMax = 0;
        for(int i = n - 1; i > maxID; i--){
            curMax = max(curMax, height[i]);
            res += curMax - height[i];
        }
        return res;
    }
};
```
```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        int left = 0;
        int right = n - 1;
        int leftMax = 0, rightMax = 0, res = 0;
        while(left < right){
            if(height[left] < height[right]){
                leftMax = max(leftMax, height[left]);
                res += leftMax - height[left];
                left++;
            }else{
                rightMax = max(rightMax, height[right]);
                res += rightMax - height[right];
                right--;
            }
        }
        return res;
    }
};
```

### 4. 复杂度分析

- **时间复杂度**: $O(N)$。一次找最大值，随后两次线性遍历（或双指针一次遍历），整体线性。
- **空间复杂度**: $O(1)$。只使用若干标量变量，不依赖额外数组。

### 5. 总结与反思

- **双指针**：双指针法是常用且简洁的替代方案，代码短且同样 O(N)、O(1) 空间，推荐掌握。  