# LeetCode 11. 盛水最多的容器

### 1. 题目链接

[https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-100-liked]

### 2. 我的初次思路与遇到的问题 (The Error in "Error Log")

*在这里详细记录你最开始的想法，哪怕是错误的。*

两个指针分别从数组两端向中间靠拢，每次求两个指针之间容纳的最多的水（两者较小值乘以两者距离）。因为要求最大值，所以每次应该是移动值较小的的那个指针。记录一个max，直到两指针相遇。

### 3. 核心解法：双指针

**3.1 思路分析**

双指针可以将复杂度优化到 $O(N)$。

1.  **定义指针**：我们使用两个指针，`left` 指向数组的起始位置，`right` 指向数组的末尾位置。

2.  **计算与移动**：
    *   在 `left < right` 的循环中，计算当前指针构成的最大容器面积：`area = (right - left) * min(height[left], height[right])`。
    *   用当前面积 `area` 更新最大面积 `res`。
    *   如何移动指针？容器的面积由 **宽度** 和 **较短的板** 决定。唯一可能找到更大面积的策略是移动**较短的板**，即 `if (height[left] < height[right])`，则 `left++`，反之 `right--`。


3.  **循环终止**：当 `left` 和 `right` 相遇时，宽度为0，遍历结束。`res` 中保存的就是最大面积。

**3.2 代码实现 (C++)**

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0;
        int right = height.size() - 1;
        int res = 0;
        while(left < right){
            if(height[left] < height[right]){
                res = max(res, (right - left) * height[left++]);
            }
            else{
                res = max(res, (right - left) * height[right--]);
            }
        }
        return res;
    }
};
```

### 4. 复杂度分析

- **时间复杂度**: $O(N)$。
- **空间复杂度**: $O(1)$。

### 5. 总结与反思

- **双指针（首尾指针）**：非常适合处理有序或类似本题这种从两端逼近寻找最优解的场景。
- **贪心思想**：每次移动都选择移动短板，是一种贪心策略。排除了移动长板这个不可能产生更优解的选项，缩减了搜索空间。