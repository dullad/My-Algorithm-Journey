# LeetCode 283. 移动零

### 1. 题目链接

[https://leetcode.cn/problems/move-zeroes/?envType=study-plan-v2&envId=top-100-liked]

### 2. 我的初次思路与遇到的问题 (The Error in "Error Log")

*在这里详细记录你最开始的想法，哪怕是错误的。*

可以转换成：所有非零元素依次放在数组前面，然后后面多余的部分置0。用`i`遍历数组，用`j`来表示非零元素需要放置的位置。

### 3. 核心解法：双指针

**3.1 思路分析**

这个问题的核心要求是**原地**修改数组，并且要保持所有非零元素的相对顺序。双指针法是解决此类问题的经典策略。

1.  **定义指针**：我们使用两个指针，一个“快指针” `i` 和一个“慢指针” `j`。
    *   **快指针 `i`**：负责遍历整个数组，寻找非零元素。
    *   **慢指针 `j`**：指向下一个非零元素应该被放置的位置。

2.  **一次遍历**：
    *   `j` 初始化为 0。
    *   `i` 从 0 开始遍历整个数组 `nums`。
    *   当 `i` 遇到一个非零元素 `nums[i]` 时，就将这个非零元素赋值给 `nums[j]`，然后将 `j` 向后移动一位（`j++`）。
    *   如果 `nums[i]` 是零，则 `j` 不动，`i` 继续前进。

3.  **填充零**：
    *   当第一次遍历结束后，所有非零元素都已经被按顺序移动到了数组的前 `j` 个位置（即 `[0, j-1]`）。
    *   数组剩下的 `[j, nums.size() - 1]` 的位置，就应该全部填充为零。

这个方法通过一次遍历就将非零元素“压缩”到了数组的开头，并保持了它们的相对顺序。

**3.2 代码实现 (C++)**

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int j = 0;
        for(int i = 0; i < nums.size(); i++){
            if(nums[i] != 0){
                nums[j++] = nums[i];
            }
        }
        for(; j < nums.size(); j++){
            nums[j] = 0;
        }
    }
};
```

### 4. 复杂度分析

- **时间复杂度**: $O(N)$。其中 $N$ 是数组 `nums` 的长度。快指针 `i` 和慢指针 `j` 都只从头到尾遍历了一次数组。
- **空间复杂度**: $O(1)$。我们只使用了常数个额外变量（`i` 和 `j`），是在原地修改数组，没有使用额外的存储空间。

### 5. 总结与反思

- **双指针思想**：慢指针 `j` 划分了数组的边界：`[0, j-1]` 是处理好的非零元素区域，而 `[j, i-1]` 是待处理或已确认为零的区域。
- **保持相对顺序**：通过让慢指针 `j` 只有在放置非零元素时才移动，该算法天然地保证了所有非零元素的原始相对顺序不被打乱。