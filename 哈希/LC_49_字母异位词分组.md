# LeetCode 49. 字母异位词分组

### 1. 题目链接

[https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked]

### 2. 我的初次思路与遇到的问题 (The Error in "Error Log")

*在这里详细记录你最开始的想法，哪怕是错误的。*

开始的思路是：首先拷贝字符串数组副本，对字符串数组副本字符排序，如果是字母异位词，则排序后结果相同。

### 3. 核心解法：哈希表

**3.1 思路分析**

“字母异位词”的核心特征：**组成它们的字母完全相同，只是顺序不同** ，因此排序后的字符串就是异位词的共同标签。

以排序后的字符串作为键，其值可以直接设计成`vector<string>`，存放所有排序后为该字符串样式的字符串，这样在其值处可以直接通过`.push_back(str)`存储。

1.  创建一个哈希表，其中：
    *   **键 (Key)**：一个字符串排序后的结果。
    *   **值 (Value)**：一个字符串列表，用来存放所有排序后等于该键的原始字符串。
2.  遍历输入的字符串数组 `strs` 中的每一个字符串 `str`。
3.  对于每个 `str`，创建一个副本 `copy_str` 并对其进行排序。
4.  将原始字符串 `str` 添加到哈希表中以 `copy_str` 为键的那个列表里。
5.  遍历结束后，哈希表中的所有值（也就是那些字符串列表）就是我们想要的最终分组结果。

**3.2 代码实现 (C++)**

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> map;//<排序后，<原词向量>>相当于排序后作为唯一标识
        for(auto& str: strs){
            string copy_str = str;
            sort(copy_str.begin(), copy_str.end());
            map[copy_str].push_back(str);
        }
        vector<vector<string>> res;
        for(auto& pair: map){
            res.push_back(pair.second);
        }
        return res;
    }
};
```

### 4. 复杂度分析

- **时间复杂度**: $O(N \cdot K \log K)$。
  - 其中 $N$ 是字符串数组 `strs` 的长度，而 $K$ 是数组中字符串的最大长度。
  - 我们需要遍历 $N$ 个字符串。对于每个字符串，我们需要花费 $O(K \log K)$ 的时间来对其进行排序。哈希表的插入操作平均时间复杂度接近 $O(K)$（因为需要计算字符串哈希值），但排序是主导因素。
- **空间复杂度**: $O(N \cdot K)$。

### 5. 总结与反思

- **寻找不变性**：解决此题的关键是找到一个“不变量”来标识一组字母异位词。本题中即为排序后的字符串
- **哈希表的映射能力**：哈希表在这里不仅仅是用于查找，更是作为一种强大的“分组”或“归类”工具。它能将具有相同特征（排序后相同）的元素自动聚合在一起。
- **优化思路（计数代替排序）**：对于只包含小写字母的场景，排序操作 $O(K \log K)$ 并非最优。我们可以通过计数来优化。创建一个大小为26的数组作为键，统计每个字符串中各字母出现的次数。这样可以将单个字符串的处理时间从 $O(K \log K)$ 降低到 $O(K)$，从而将总时间复杂度优化到 $O(N \cdot K)$。