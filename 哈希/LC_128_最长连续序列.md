# LeetCode 128. 最长连续序列

### 1. 题目链接

[https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked]

### 2. 我的初次思路与遇到的问题 (The Error in "Error Log")

*在这里详细记录你最开始的想法，哪怕是错误的。*

开始的思路是：将数组中所有元素存入哈希表，然后从哈希表第一个元素开始去向左、右分别查找是否有连续元素，直到查到不连续的元素，每查到一个元素，`sum++`，并且在表中去除这个查到的元素，以避免重复查找。这样每次查找都是包含第一个元素的最长序列。

### 3. 核心解法：哈希表

**3.1 思路分析**

我的初次思路时间复杂度达到了`O(n)`，大体上没问题，不断双向搜索，直到集合为空，就找到了最长序列。但是需要删除元素。

另一种广泛使用的`O(n)`思路，只遍历，不删除：**如果`num-1`存在，说明`num`不是序列起点，可以跳过它；**如果`num-1`不存在，说明`num`是序列起点，那么从`num`开始，检查以其为首的连续数字是否在`set`中并计数，直到序列中断。这个方法通过只对序列的“起点”进行扩展，巧妙地避免了重复计算，同样保证了每个元素只被访问常数次。

**3.2 代码实现 (C++)**

```c++
// 我的初次思路代码实现
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> set;
        for(auto num: nums){
            set.insert(num);
        }
        int res = 0;
        while(!set.empty()){
            int temp = *set.begin();
            int sum = 1;
            int right = temp;
            int left = temp;
            set.erase(temp);
            while(set.find(++right) != set.end()){
                sum++;
                set.erase(right);
            }
            while(set.find(--left) != set.end()){
                sum++;
                set.erase(left);
            }
            res = max(res, sum);
        }
        return res;
    }
};
```

```c++
//题解，只遍历，不删除
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> set;
        for(auto num:nums){
            set.insert(num);
        }
        int res=0;
        for(auto num:set){
            if(!set.count(num-1)){//只有num-1不存在时，才可作为序列首
                int sum=1;
                while(set.count(num+1)){
                    sum++;
                    num++;
                }
                res=max(res,sum);
            }
        }
        return res;
    }
};
```

### 4. 复杂度分析

- **时间复杂度**: $O(N)$。
- **空间复杂度**: $O(N)$。

### 5. 总结与反思

- **空间换时间**：时间复杂度要求为`O(n)`，因此不能排序。通过哈希表降低查找的时间复杂度。
- **避免重复计算**：无论是通过“删除元素”还是通过“只从起点开始枚举”，两种 O(N) 解法的核心都在于设计一个机制来**避免对同一个序列的重复计数**。这是将看似 $O(N^2)$ 的暴力枚举优化到 $O(N)$ 的关键。
- **`unordered_set` 的使用**：`unordered_set` 在处理关于数字存在性、去重等问题时非常高效。熟练掌握其 `insert`, `find`, `erase`, `empty` 等基本操作是解决这类问题的基础。同时注意`int temp = *set.begin();`操作。也可以用`set.count(num)`来查找`num`是否存在。