# LeetCode 239. 滑动窗口最大值

### 1. 题目链接

[https://leetcode.cn/problems/sliding-window-maximum/?envType=study-plan-v2&envId=top-100-liked]

### 2. 我的初次思路与遇到的问题 (The Error in "Error Log")

*在这里详细记录你最开始的想法，哪怕是错误的。*

### 3. 核心解法：前缀和 + 哈希表优化

**3.1 思路分析**

我们需要一个数据结构，能在 $O(1)$ 时间内获取当前窗口的最大值，并且能随着窗口移动高效地移除过期元素。标准的队列无法做到 $O(1)$ 获取最大值，而堆（优先队列）删除任意元素较慢。因此，我们采用**单调队列**。

1.  **单调递减性**：
    队列中存储的是元素的数值（或者下标）。我们维护队列元素**单调递减**。
    *   为什么是递减？因为如果队列中前面有一个小元素 `a`，后面来了一个大元素 `b`，只要 `b` 在窗口内，`a` 永远不可能是最大值（`a` 比 `b` 小且比 `b` 早“过期/离开窗口”）。所以 `a` 是“由于 `b` 的存在而变得无用的元素”，应该被弹出。

2.  **队列操作流程**（遍历数组 `nums[i]`）：
    *   **入队前维护单调性**：如果在队尾的元素小于当前元素 `nums[i]`，说明队尾元素“太小且太老”，永远不会成为最大值，直接 `pop_back()`。重复此过程直到队尾元素大于 `nums[i]` 或队列为空，然后将 `nums[i]` `push_back()`。
    *   **检查队头过期**：检查队头元素（即当前最大值）是否已经滑出了窗口左边界。如果是（即 `nums[i-k] == deque.front()`），则 `pop_front()`。
    *   **记录结果**：当窗口完全形成后（即 `i >= k - 1`），队头元素 `deque.front()` 就是当前窗口的最大值。


**3.2 代码实现 (C++)**
```C++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        if(nums.size() == 0 || k == 0) return {};
        deque<int> deque;
        vector<int> res(nums.size() - k + 1);
        // 先把k-1个元素入队，单独处理第一个窗口
        for(int i = 0; i < k; i++){
            while(!deque.empty() && nums[i] > deque.back()){//注意维护单调队，是和队尾一个一个比较删除，而不是front
                deque.pop_back();
            }
            deque.push_back(nums[i]);
        }
        res[0] = deque.front();
        for(int i = k; i < nums.size(); i++){
            // 如果被移除元素为最大值，则出队
            if(nums[i-k] == deque.front()){
                deque.pop_front();
            }
            // 维护单调队
            while(!deque.empty() && nums[i] > deque.back()){
                deque.pop_back();
            }
            deque.push_back(nums[i]);
            res[i - k + 1] = deque.front();
        }
        return res;

    }
};
```

### 4. 复杂度分析

- **时间复杂度**: $O(N)$。**每个元素最多进队一次，出队一次**。
    因此，总的操作次数是线性的，平摊到每个元素上是 $O(1)$。
- **空间复杂度**: $O(K)$。
    双端队列 `deque` 中最多存储 $K$ 个元素（当窗口内的元素单调递减时）。

### 5. 总结与反思

- **单调队列核心思想 (Monotonic Queue)**：
    单调队列主要用于解决**“滑动窗口最值”**相关的问题。
    *   **核心逻辑（比喻）**：“如果一个新来的选手比你年轻（下标大），还比你强（数值大），那你就可以退役了”。
    *   **操作特性**：
        1.  **入队时维护单调性**：从队尾加入，为了保持单调递减，需要将队尾所有比当前元素小的元素弹出 (`pop_back`)。
        2.  **出队时维护时效性**：从队头弹出 (`pop_front`)，用于移除滑出窗口左边界的过期元素。
        3.  **取值**：队头元素 (`front`) 始终是当前窗口的最值。
    
- **最佳实践：存下标 vs 存数值**
    *   **存数值**（本题我的解法）：代码直观，但判断元素是否滑出窗口时（`if(nums[i-k] == deque.front())`），需要确保逻辑严密（比如处理重复元素）。
    *   **存下标**（更推荐）：队列中存储数组的 `index`。
        *   判断过期非常简单：`if (deque.front() <= i - k) deque.pop_front()`。
        *   取最大值：`nums[deque.front()]`。
        *   这种方式更通用，不易出错。

- **问题模版**：遇到“滑动窗口” + “最大/最小值”问题，优先考虑单调队列。
