# LeetCode 560. 和为K的子数组

### 1. 题目链接

[https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked]

### 2. 我的初次思路与遇到的问题 (The Error in "Error Log")

*在这里详细记录你最开始的想法，哪怕是错误的。*

### 3. 核心解法：前缀和 + 哈希表优化

**3.1 思路分析**

如果不使用优化手段，暴力枚举所有子数组 $[j, i]$ 并求和的时间复杂度是 $O(N^3)$ 或 $O(N^2)$，显然会超时。我们需要利用**前缀和**将问题转化。

1.  **定义前缀和**：
    设 `pre[i]` 为数组 `nums[0...i]` 的和。
    那么，任意连续子数组 `nums[j...i]` 的和可以表示为：
    $$sum(j, i) = pre[i] - pre[j-1]$$

2.  **问题转化**：
    我们要找和为 `k` 的子数组 $[j, i]$，也就是寻找满足条件的下标对 $(j, i)$，使得：
    $$pre[i] - pre[j-1] == k$$
    移项可得：
    $$pre[j-1] == pre[i] - k$$

3.  **哈希表优化**：
    当我们遍历到位置 `i` 时，我们需要知道在 `i` 之前（即 $0$ 到 $i-1$ 范围内），有多少个位置 `j-1` 的前缀和等于 `pre[i] - k`。
    与其重复扫描前面的元素，不如用一个哈希表 `unordered_map<int, int>` 实时记录：
    *   **Key**: 前缀和的值
    *   **Value**: 该前缀和出现的次数

    **算法流程**：
    *   初始化 `map[0] = 1`（代表前缀和为0出现了一次，处理子数组从下标0开始的情况）。
    *   遍历数组，维护当前累加和 `pre`。
    *   查找 `map` 中是否存在键 `pre - k`。如果存在，加上对应的值到 `ans`。
    *   将当前的 `pre` 更新入 `map`。

**3.2 代码实现 (C++)**
```C++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> map;
        map[0]=1;
        int pre = 0, ans = 0;
        for(int i = 0; i < nums.size(); i++){
            pre += nums[i];
            if(map.find(pre - k) != map.end()){//前缀为pre-k的，均满足和为k
                ans += map[pre - k];
            }
            map[pre]++;//pre加入map
        }
        return ans;
    }
};
```

### 4. 复杂度分析

- **时间复杂度**: $O(N)$。我们遍历数组的时间复杂度为 O(n)，中间利用哈希表查询的复杂度为 O(1)
- **空间复杂度**: $O(N)$。在最坏的情况下，可能有n个不同的键值。

### 5. 总结与反思

- **前缀和技巧总结 (Prefix Sum Patterns)**：
    前缀和主要用于解决**“连续子数组区间和”**相关的问题。
    *   **核心公式**：`sum[i..j] = pre[j] - pre[i-1]`。
    *   **常见组合**：前缀和常与**哈希表**结合使用。当问题涉及“求和为K的子数组数量”、“和为K的最长子数组长度”时，通常可以将 $O(N^2)$ 的暴力解法优化为 $O(N)$。
    *   **初始化细节**：永远不要忘记初始化 `map[0] = 1` 或 `map[0] = -1`，这一步是为了处理那些从数组下标 0 开始就满足条件的子数组（即 $pre[i] - 0 = k$ 的情况）。
- **问题模版**：遇到“连续子数组” + “和/计数”问题，优先考虑前缀和。
