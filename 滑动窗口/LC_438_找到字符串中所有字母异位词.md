# LeetCode 438.找到字符串中所有字母异位词

### 1. 题目链接

[https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked]

### 2. 我的初次思路与遇到的问题 (The Error in "Error Log")

*在这里详细记录你最开始的想法，哪怕是错误的。*

异位词长度一定相同，因此若s长度小于p，则一定不存在异位词。
在s中构造长度与p相同的滑窗，维护p的哈希表以及滑窗的哈希表，若两表相同则说明为异位词。将窗口第一个元素的下标加入ans向量中。
滑动窗口，第一个窗口在循环外处理完成，后续循环只需要滑动即可。

### 3. 核心解法
## 方法一：直接滑动窗口
与上述思路一致。注意`s.length() < p.length()`时单独处理。
维护`map_p`与`map_window`
```C++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int len_p = p.length();
        if(s.length() < len_p) return vector<int>(); //不存在异位词
        vector<int> ans;
        vector<int> map_p(26);
        vector<int> map_window(26);
        for(int i = 0; i < p.length(); i++){
            map_p[p[i] - 'a']++;
            map_window[s[i] - 'a']++;
        }
        if(map_p == map_window) ans.push_back(0);
        for(int i = 0; i < s.length() - len_p; i++){
            map_window[s[i] - 'a']--;
            map_window[s[i + len_p] - 'a']++;
            if(map_p == map_window){
                ans.push_back(i + 1);
            }
        }
        return ans;
    }
};
```
* 时间复杂度为：`O(m+(n-m)*26)`
* 空间复杂度为：`O(26)`

## 方法二：优化的滑动窗口
统计窗口和字符串`p`中每种字母数量的差，引入`num_differ`记录当前窗口与字符串`p`中数量不同的字母的个数，在滑动窗口过程中维护`num_differ`，只有`num_differ`为0时，代表当前窗口中字符串与目标字符串为异位词。
`for(int i = 0; i < s.length() - len_p; i++)`，对于每个i，表示`s[i]`这个字母要被移出，`s[i_len_p]`这个字母要被移入。
```C++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int len_p = p.length();
        if(s.length() < len_p) return vector<int>();//数组越界
        vector<int> ans;
        vector<int> map(26);
        int num_differ = 0;
        for(int i = 0; i < p.length(); i++){
            map[s[i] - 'a']++; // s进来增加，p进来减少
            map[p[i] - 'a']--;
        }
        for(int i = 0; i < 26; i++){
            if(map[i] != 0) num_differ++;
        }
        if(num_differ == 0) ans.push_back(0);
        for(int i = 0; i < s.length() - len_p; i++){
            //移出一个，移进一个，分别处理map和num_differ
            if(map[s[i] - 'a'] == 1){ //移出前刚好多一个，那么移除后个数就相同了
                num_differ--;
            }else if(map[s[i] - 'a'] == 0){ //移除前相同，那么移除后变不同了
                num_differ++;
            }
            map[s[i] - 'a']--; //移除窗口内第一个元素

            if(map[s[i+len_p] - 'a'] == -1){ //移入前刚好少一个，那么移入后个数就相同了
                num_differ--;
            }else if(map[s[i+len_p] - 'a'] == 0){ //移入前相同，那么移入后变不同了
                num_differ++;
            }
            map[s[i+len_p] - 'a']++; //移入窗口后第一个元素

            if(num_differ == 0) ans.push_back(i + 1);
        }
        return ans;
    }
};
```
* 时间复杂度为：`O(n+m+26)`
* 空间复杂度为：`O(26)`

## 方法三：不定长窗口
统计窗口内字符和目标字符的差异。但是窗口长度是滑动的，由`left`和`right`来限定窗口。
当新进窗口的字符比目标串对应字符多，则`left`右移，直到`right`对应的字符与目标串对应字符数量一致。此时如果窗口长度与目标字符串长度一致，则`left`进入`ans`。
因为机制保证窗口内一定不会有数量比目标字符串字符多的，所以如果窗口长度还一样的话，说明窗口和目标字符串一定是异位词。

```C++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int len_p = p.length();
        vector<int> ans;
        vector<int> map(26);
        for(int i = 0; i < p.length(); i++){
            map[p[i] - 'a']++;
        }
        int left = 0;
        for(int right = 0; right < s.length(); right++){
            map[s[right] - 'a']--;
            while(map[s[right] - 'a'] < 0){//窗口内这个字符太多了
                map[s[left] - 'a']++;
                left++;
            }
            if(right - left + 1 == len_p) ans.push_back(left);
        }
        return ans;
    }
};
```
* 时间复杂度为：`O(n+m)`
* 空间复杂度为：`O(26)`
