# LeetCode 3.无重复字符的最长子串

### 1. 题目链接

[https://leetcode.cn/problems/longest-substring-without-repeating-characters/?envType=study-plan-v2&envId=top-100-liked]

### 2. 我的初次思路与遇到的问题 (The Error in "Error Log")

*在这里详细记录你最开始的想法，哪怕是错误的。*

滑动窗口，left指向窗口左下标，right指向窗口右下标。建立哈希表用来记录字符出现的次数。right一直向右移动，每移动一次后更新哈希表，如果新进窗口的字符有重复（哈希值大于1），则需要left一直向右移，直到新进窗口的那个字符没有重复。去重以后计算无重复字符串长度，如果大于最大值则更新最大值。这样始终保证窗口内的字符无重复，再计算窗口的长度，直到right到达字符数组边界，就能得到最大值。

### 3. 核心解法：双指针

**3.1 思路分析**

本题要求找到“最长”的“无重复字符”的“子串”，是滑动窗口算法的经典应用场景。

1.  **定义窗口和指针**：我们使用两个指针 `left` 和 `right` 来定义一个左闭右闭的窗口 `[left, right]`。这个窗口代表我们正在考察的子串。

2.  **维护窗口状态**：为了快速判断窗口内是否有重复字符，我们使用一个哈希表 `map` 来记录窗口内每个字符出现的次数。

3.  **窗口的移动逻辑**：
    *   `right` 指针不断向右移动，将新字符 `s[right]` 纳入窗口，并更新其在 `map` 中的计数。
    *   **收缩条件**：当发现 `map[s[right]] > 1` 时，说明窗口内出现了重复字符。此时，我们需要收缩窗口。
    *   **如何收缩**：`left` 指针不断向右移动，将 `s[left]` 移出窗口，并将其在 `map` 中的计数减一，直到 `map[s[right]]` 的值重新变回 1 为止。这表示窗口内又没有重复字符了。

4.  **更新结果**：在每一次 `right` 指针移动后（即窗口扩张后），窗口 `[left, right]` 都是一个有效的无重复字符子串。我们计算其长度 `right - left + 1`，并用它来更新最大长度 `maxLen`。

**3.2 代码实现 (C++)**

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.length() <= 1) return s.length();
        int right = 0, left = 0, maxLen = 0;
        unordered_map<char, int> map;
        while(right < s.length()){
            map[s[right]] += 1;
            while(map[s[right]] > 1){
                map[s[left++]] -= 1;
            }
            // 先去重再计算长度
            int len = right - left + 1;
            if(len > maxLen){
                maxLen = len;
            }
            right++;
        }
        return maxLen;
    }
};
```

### 4. 复杂度分析

-  **时间复杂度**: $O(N)$。其中 $N$ 是字符串 `s` 的长度。虽然代码中有嵌套的 `while` 循环，但 `left` 和 `right` 两个指针都各自从头到尾只遍历了字符串一次，所以总的时间复杂度是线性的。
-  **空间复杂度**: $O(|\Sigma|)$。其中 $|\Sigma|$ 是字符集的大小。哈希表中最多存储字符集大小的键值对，因此空间复杂度可以看作是常数 $O(1)$。

### 5. 总结与反思

-  **滑动窗口模板**：本题是滑动窗口算法的一个标准模板。其核心思想是：用 `right` 指针扩张窗口，当窗口状态不满足条件时，用 `left` 指针收缩窗口，直到再次满足条件。
-  **状态更新时机**：本题要求的是“最长”，所以我们在每次窗口扩张后（即保证窗口有效时）都去更新最大长度。
-  **哈希表**：注意哈希表的使用，及时回顾。